LINUX COMMANDS

 1. Linux Commands and Pipes
- Description: In Linux, commands are executed in the terminal, and pipes (`|`) are used to connect the output of one command to the input of another. This allows for efficient data processing and chaining of commands.
- Example: `ls -l | grep "test"` lists all files in the current directory and filters the output to show only files containing the word "test".

 2. Linux Terminal and Key Concepts
- Description: The Linux terminal is a command-line interface that allows users to interact with the operating system using text-based commands.
- Key Concepts: 
  - Shell: A program that processes commands.
  - Bash: The default shell in most Linux distributions.
  - Prompt: The text displayed by the shell indicating it is ready for commands (e.g., `$` or `#`).

 3. Finding Manuals and Resources
- Description: Linux provides built-in manuals through the `man` command to get information on various commands.
- Example: `man ls` displays the manual page for the `ls` command, explaining its options and usage.

 4. Linux Directories and Their Organization
- Description: Linux uses a hierarchical file system where everything is treated as a file, including directories. The top-level directory is `/` (root).
- Examples:
  - `/bin`: Essential binary commands.
  - `/etc`: Configuration files.
  - `/home`: Home directories for users.

 5. Linux Shell and Its Role
- Description: The shell is an interpreter that translates user commands into actions by the operating system. It's essential for executing scripts, managing processes, and system administration tasks.

 6. Working with the `ls` Command
- Description: The `ls` command lists directory contents.
- Example: `ls -a` lists all files, including hidden ones. `ls -lh` lists files with human-readable sizes.

 7. Relative and Absolute Pathnames
- Description: 
  - Absolute Path: Starts from the root directory (e.g., `/home/user/documents`).
  - Relative Path: Starts from the current directory (e.g., `./documents`).

 8. Filtering `ls` Output
- Example: `ls -l | grep "^d"` filters output to show only directories.

 9. Copying Files and Directories (`cp` Command)
- Description: `cp` is used to copy files or directories.
- Example: `cp source.txt destination.txt` copies `source.txt` to `destination.txt`.

 10. Tab Auto-Completion
- Description: Tab auto-completion in the terminal helps complete commands or file names quickly by pressing the `Tab` key.

 11. Symbolic and Hard Links
- Description: Links are references to files:
  - Hard Link: Direct reference to the inode of the original file.
  - Symbolic Link (Symlink): Points to the filename.
- Example: `ln source.txt link.txt` creates a hard link; `ln -s source.txt link.txt` creates a symlink.




------less command

 `less` Command:
The `less` command in Linux is used to view the content of a file one screen at a time. It is a powerful file viewer that allows forward and backward navigation through the content of a file.

# Key Points:
1. Basic Usage: `less [options] file_name`
   - Opens the specified file for viewing.

2. Navigation:
   - Arrow keys: Scroll line by line (up and down).
   - Page Up (`b`) / Page Down (`f`): Scroll up or down one page.
   - `g`: Go to the beginning of the file.
   - `G`: Go to the end of the file.
   - `/search_term`: Search for a term (press `n` to go to the next occurrence, `N` to go to the previous).
   - `q`: Quit the `less` viewer.

3. Options:
   - `-N`: Display line numbers.
   - `-S`: Disable line wrapping (truncates long lines).
   - `-i`: Ignore case while searching.
   - `+F`: Follow mode, similar to `tail -f` (useful for watching logs).

# Examples:

1. View a File:
   
   less myfile.txt
   
   - Opens `myfile.txt` for viewing, allowing navigation with the keyboard.

2. View a File with Line Numbers:
   
   less -N myfile.txt
   
   - Opens `myfile.txt` and displays line numbers.

3. Search for a Word in a File:
   
   less myfile.txt
   
   - While in `less`, type `/word` to search for "word". Use `n` to find the next occurrence and `N` for the previous one.

4. Disable Line Wrapping:
   
   less -S myfile.txt
   
   - Opens `myfile.txt` with lines truncated instead of wrapped.

5. Follow a Log File:
   
   less +F /var/log/syslog
   
   - Opens `/var/log/syslog` in "follow mode" to view new lines as they are added, similar to `tail -f`.

6. Case-Insensitive Search:
   
   less -i myfile.txt
   
   - Opens `myfile.txt` and allows case-insensitive search.

 Additional Tips:
- Marking a Position: Press `m` followed by any letter to mark a position in the file. To return to it, press `'` followed by that letter.
- Jump to a Line: Type `:` followed by a line number to jump directly to that line.



----- CP command

The `cp` (copy) command in Linux is used to copy files and directories from one location to another.

 Key Points:
1. Basic Usage: `cp [options] source destination`
   - Copies the `source` file or directory to the `destination`.

2. Options:
   - `-i`: Interactive mode. Asks for confirmation before overwriting.
   - `-r` or `-R`: Recursive. Copies directories and their contents.
   - `-v`: Verbose. Displays the files being copied.
   - `-u`: Updates the destination file only if the source file is newer.

3. Default Behavior: By default, `cp` will overwrite files without warning.

 Examples:
1. Copy a File:
   
   cp file1.txt file2.txt
   
   - Copies `file1.txt` to `file2.txt`. If `file2.txt` exists, it will be overwritten.

2. Copy a Directory:
   
   cp -r /source_dir /destination_dir
   
   - Copies all files and subdirectories from `source_dir` to `destination_dir`.

3. Interactive Copy:
   
   cp -i file1.txt /backup/
   
   - Asks for confirmation before overwriting a file in the `/backup/` directory.

4. Verbose Copy:
   
   cp -v file1.txt file2.txt
   
   - Copies `file1.txt` to `file2.txt` and displays the copy progress.

5. Update Only if Newer:
   
   cp -u source.txt destination.txt
   
   - Copies `source.txt` to `destination.txt` only if `source.txt` is newer.

Would you like more examples or further clarification on any options?




------links

Hard links and soft links are both ways to reference files in Linux, but they differ in how they reference the data: 
 
Hard links
Point directly to the data of the original file, making them mirror copies of the original file. Hard links share the same inode number as the original file. If the original file is deleted, the hard link will still have the original file's data. 
 
Soft links
Also known as symbolic links, soft links point to the path to the original file, not the data itself. Soft links have a unique inode number from the original file. If the original file is deleted, the soft link will no longer work because it points to a non-existent file. 
 
The ln command can be used to create links, with ln creating a hard link by default and ln -s creating a symbolic link. 
 



------mkdir

 `mkdir` Command:
The `mkdir` (make directory) command is used to create new directories in Linux.

# Key Points:
1. Basic Usage: `mkdir [options] directory_name`
   - Creates a new directory with the specified name.

2. Options:
   - `-p`: Creates parent directories as needed.
   - `-v`: Verbose. Displays a message for each directory created.

# Examples:
1. Create a Single Directory:
   
   mkdir myfolder
   
   - Creates a directory named `myfolder` in the current location.

2. Create a Directory and Its Parents:
   
   mkdir -p /home/user/newfolder/subfolder
   
   - Creates `newfolder` and `subfolder` in the specified path, even if the parent directories do not exist.

3. Verbose Mode:
   
   mkdir -v myfolder
   
   - Displays a message confirming the creation of `myfolder`.



-------`mv` Command:
The `mv` (move) command is used to move or rename files and directories.

# Key Points:
1. Basic Usage: `mv [options] source destination`
   - Moves `source` to `destination` or renames `source` to `destination`.

2. Options:
   - `-i`: Interactive mode. Prompts before overwriting.
   - `-v`: Verbose. Displays the movement of files.
   - `-n`: No-clobber. Do not overwrite existing files.

# Examples:
1. Move a File:
   
   mv file1.txt /backup/
   
   - Moves `file1.txt` to the `/backup/` directory.

2. Rename a File:
   
   mv oldname.txt newname.txt
   
   - Renames `oldname.txt` to `newname.txt`.

3. Interactive Move:
   
   mv -i file1.txt /backup/
   
   - Prompts before overwriting any existing file named `file1.txt` in `/backup/`.

4. Verbose Move:
   
   mv -v file1.txt /backup/
   
   - Moves `file1.txt` to `/backup/` and displays the operation.




------- `rm` Command:
The `rm` (remove) command is used to delete files and directories.

# Key Points:
1. Basic Usage: `rm [options] file_name`
   - Deletes the specified file or directory.

2. Options:
   - `-i`: Interactive mode. Asks for confirmation before each removal.
   - `-r`: Recursive. Deletes directories and their contents.
   - `-f`: Force. Deletes files or directories without confirmation.
   - `-v`: Verbose. Displays information about the files being deleted.

# Examples:
1. Delete a File:
   
   rm file1.txt
   
   - Deletes `file1.txt`.

2. Delete a Directory and Its Contents:
   
   rm -r myfolder
   
   - Deletes the directory `myfolder` and all its contents.

3. Force Delete Without Confirmation:
   
   rm -f file1.txt
   
   - Deletes `file1.txt` without asking for confirmation.

4. Interactive Delete:
   
   rm -i file1.txt
   
   - Asks for confirmation before deleting `file1.txt`.

5. Verbose Delete:
   
   rm -v file1.txt
   
   - Deletes `file1.txt` and displays a message about the deletion.



------echo command

 `echo` Command:
The `echo` command in Linux is used to display a line of text or a variable value to the terminal.

# Key Points:
1. Basic Usage: `echo [options] [string]`
   - Prints the specified string or variable to the terminal.

2. Options:
   - `-n`: Do not output the trailing newline (prints text without adding a new line at the end).
   - `-e`: Enable interpretation of backslash escapes (e.g., `\n` for new line, `\t` for tab).
   - `-E`: Disable interpretation of backslash escapes (default behavior).

3. Common Uses: 
   - Printing text, displaying variable values, formatting output, or creating simple scripts.

# Examples:

1. Print a Simple Text String:
   
   echo "Hello, World!"
   
   - Outputs: `Hello, World!`

2. Print Without a New Line:
   
   echo -n "Hello, "
   echo "World!"
   
   - Outputs: `Hello, World!` (on the same line without a newline after "Hello,")

3. Print with Special Characters:
   
   echo -e "Hello,\nWorld!"
   
   - Outputs: 
   
   Hello,
   World!
   
   - The `-e` option enables interpretation of the newline character `\n`.

4. Print a Variable's Value:
   
   name="Alice"
   echo "Hello, $name!"
   
   - Outputs: `Hello, Alice!`

5. Redirect Output to a File:
   
   echo "This is a line of text." > output.txt
   
   - Creates (or overwrites) `output.txt` with the specified text.

6. Append Text to a File:
   
   echo "This line will be added to the file." >> output.txt
   
   - Appends the specified text to `output.txt`.



-------automating folder creation

To automate folder creation in Linux, you can use a combination of the `mkdir` command and a script (usually written in Bash). Here are some methods to automate creating multiple directories:

 Key Points:
1. Basic Usage: Automating folder creation involves writing a script that utilizes the `mkdir` command.
2. Common Use Cases: Quickly set up project directories, create dated folders, or generate a series of folders based on a pattern or input.

 Examples:

# 1. Create Multiple Directories in One Command:
You can create multiple directories in a single command by specifying all the directory names:

mkdir folder1 folder2 folder3

- Creates `folder1`, `folder2`, and `folder3` in the current directory.

# 2. Create Directories Using a Bash Script:
You can automate folder creation using a Bash script to generate multiple folders.

Example Script:

#!/bin/bash

# Define the base directory
base_dir="my_project"

# Create the base directory
mkdir -p "$base_dir"

# Array of subdirectories to create
subdirs=("src" "bin" "docs" "tests")

# Loop to create subdirectories
for subdir in "${subdirs[@]}"; do
  mkdir -p "$base_dir/$subdir"
done

echo "Directories created successfully!"

- This script creates a base directory `my_project` and subdirectories `src`, `bin`, `docs`, and `tests` inside it.

# 3. Create Dated Folders Automatically:
You can create folders with the current date using the `date` command.

Example Command:

mkdir "backup_$(date +%Y-%m-%d)"

- Creates a folder named `backup_YYYY-MM-DD` with the current date.

# 4. Automate Folder Creation with a Numbered Sequence:
You can use a `for` loop to create multiple numbered folders.

Example Command:

for i in {1..5}; do
  mkdir "folder_$i"
done

- Creates folders named `folder_1`, `folder_2`, `folder_3`, `folder_4`, and `folder_5`.

# 5. Create Nested Directories:
Use the `-p` option to create nested directories in one command.

Example Command:

mkdir -p project/{src,bin,docs,tests}

- Creates a `project` directory with subdirectories `src`, `bin`, `docs`, and `tests`.

 Save and Run the Script:
1. Save the script to a file, e.g., `create_folders.sh`.
2. Make the script executable:
   
   chmod +x create_folders.sh
   
3. Run the script:
   
   ./create_folders.sh
   



---------file permissions

-    	regular file
d	directory
l	symbolic link
c	char special file
b 	block special file
r(4)	read
w(2)	write
x(1) 	execute

example
drwxr-xr-x
-d (first letter stands for file type here it is directory)
-(after first char, first three characters means user permissions , next three characters means group permissions and remaining three means world permissions)

 File and Directory Permissions in Linux:
Linux file and directory permissions control the access level that users have over files and directories. Permissions are specified for three categories of users: the owner (user), the group, and others (everyone else).

# Key Points:
1. Basic Permissions:
   - Read (`r`): Allows reading the contents of a file or listing a directory's contents.
   - Write (`w`): Allows modifying the contents of a file or adding/removing files in a directory.
   - Execute (`x`): Allows executing a file (if it is a program or script) or accessing a directory.

2. Permission Representation:
   - Symbolic: `rwx` (e.g., `rwxr-xr--`).
   - Octal (numeric): `4` for read, `2` for write, `1` for execute (e.g., `755`).

3. Commands:
   - `chmod`: Change file or directory permissions.
   - `chown`: Change the owner of a file or directory.
   - `chgrp`: Change the group ownership of a file or directory.

 Examples:

# 1. Viewing Permissions:
To view the permissions of a file or directory, use the `ls -l` command:

ls -l myfile.txt

- Output example: `-rw-r--r-- 1 user group 1234 Jan 1 10:00 myfile.txt`
  - `-rw-r--r--` indicates the permissions: 
    - `-`: File type (hyphen indicates a regular file).
    - `rw-`: Owner has read and write permissions.
    - `r--`: Group has read permissions.
    - `r--`: Others have read permissions.

# 2. Change Permissions with `chmod` (Symbolic Method):
To modify permissions using the symbolic method, specify the user category (`u`, `g`, `o`, or `a` for all) and the permission change (`+` to add, `-` to remove, `=` to set exact).

1. Add Execute Permission for the Owner:
   
   chmod u+x myfile.txt
   
   - Adds execute (`x`) permission for the owner (`u`).

2. Remove Write Permission for Others:
   
   chmod o-w myfile.txt
   
   - Removes write (`w`) permission for others (`o`).

3. Set Exact Permissions for Group:
   
   chmod g=rw myfile.txt
   
   - Sets group (`g`) permissions to read (`r`) and write (`w`) only.

# 3. Change Permissions with `chmod` (Numeric Method):
Use a three-digit number to specify the permissions:
- First Digit: Owner.
- Second Digit: Group.
- Third Digit: Others.

Common Octal Values:
- `7` = Read + Write + Execute (`rwx`).
- `6` = Read + Write (`rw-`).
- `5` = Read + Execute (`r-x`).
- `4` = Read (`r--`).
- `0` = No permissions (`---`).

1. Set Permissions to `755`:
   
   chmod 755 myfile.txt
   
   - Sets permissions to:
     - Owner: Read, write, execute (`7`).
     - Group: Read, execute (`5`).
     - Others: Read, execute (`5`).

2. Set Permissions to `644`:
   
   chmod 644 myfile.txt
   
   - Sets permissions to:
     - Owner: Read, write (`6`).
     - Group: Read (`4`).
     - Others: Read (`4`).

# 4. Change Owner with `chown`:
To change the owner of a file or directory:

chown newuser myfile.txt

- Changes the owner of `myfile.txt` to `newuser`.

# 5. Change Group with `chgrp`:
To change the group ownership of a file or directory:

chgrp newgroup myfile.txt

- Changes the group of `myfile.txt` to `newgroup`.

# 6. Change Owner and Group Simultaneously:

chown newuser:newgroup myfile.txt

- Changes both the owner to `newuser` and the group to `newgroup` for `myfile.txt`.

# 7. Recursive Permission Changes:
Use the `-R` option to apply changes to all files and subdirectories within a directory.

1. Change Permissions Recursively:
   
   chmod -R 755 /mydirectory
   
   - Sets permissions for all files and subdirectories in `/mydirectory` to `755`.

2. Change Owner Recursively:
   
   chown -R newuser /mydirectory
   
   - Changes the owner of all files and subdirectories within `/mydirectory` to `newuser`.


---------umask command

 `umask` Command:
The `umask` command in Linux sets the default permissions for newly created files and directories. It determines which permission bits will be turned off (masked) when a new file or directory is created.

# Key Points:
1. Basic Usage: `umask [options] [mask]`
   - Without arguments, it displays the current `umask` value.
   - With a mask, it sets the new default permission mask.

2. Understanding `umask`:
   - The `umask` value is a three-digit octal number representing which permissions should not be set on new files or directories.
   - Subtract the `umask` from the default permissions to determine the final permissions:
     - Default permissions for files: `666` (read and write for everyone).
     - Default permissions for directories: `777` (read, write, and execute for everyone).

3. Calculating Effective Permissions:
   - Files: Default permissions `666` minus `umask`.
   - Directories: Default permissions `777` minus `umask`.

# Examples:

1. Display the Current `umask` Value:
   
   umask
   
   - Outputs: `0022` (or another value), which shows the current `umask`.

2. Set a New `umask` Value:
   
   umask 0027
   
   - Sets the `umask` to `0027`. 
     - New files will have permissions `640` (`666 - 027`).
     - New directories will have permissions `750` (`777 - 027`).

3. Interpret the `umask` Value:
   - `0022`:
     - Files: `644` (read and write for the owner, read-only for others).
     - Directories: `755` (read, write, and execute for the owner, read and execute for others).

4. Set `umask` in Symbolic Mode:
   
   umask u=rwx,g=rx,o=
   
   - Sets the `umask` so that:
     - Owner (`u`): Read, write, and execute.
     - Group (`g`): Read and execute.
     - Others (`o`): No permissions.
   - This is equivalent to `umask 0027`.

5. Apply `umask` in a Script:
   You can set the `umask` in a script to control the permissions of any files or directories created during the script's execution.

   Example Script:
   
   #!/bin/bash

   umask 0077  # Only the owner has read, write, and execute permissions
   
   # Create a directory
   mkdir secure_dir

   # Create a file
   touch secure_file.txt

   echo "Directory and file created with restricted permissions."
   
   - In this example, both `secure_dir` and `secure_file.txt` will be created with permissions `700` and `600`, respectively.

6. Temporary `umask` Change in Shell:
   To change `umask` temporarily for the current shell session:
   
   umask 0002
   
   - Sets `umask` to `0002` for the session, where:
     - Files will be created with `664` permissions.
     - Directories will be created with `775` permissions.

7. Resetting `umask` to Default:
   
   umask 022
   
   - Resets `umask` to `022`, which is the default on many Linux systems, resulting in:
     - Files: `644` (read and write for owner, read-only for others).
     - Directories: `755` (read, write, and execute for owner, read and execute for others).



Permissions	Binary	Octal	Description
- - -		000	0	No permissions
- - x		001	1	Execute-only permission
- w -		010	2	Write-only permission
- w x		011	3	Write and execute permission
r - - 		100	4	Read-only permission
r - x 		101	5	Read and execute permission
r w -		110	6	Read and write permission
r w x		111	7	Read, write and execute permission

rw- r-- r-- MASK (022) ->	110 100 100   -> 	644
rw- r-- --- MASK (026) -> 	110 100 000   -> 	640
FULL PERMISSION -> 777
STARTS WITH (FILE)      -> 666
STARTS WITH (DIRECTORY) -> 777

Examples with directories 
rwx r-x --x MASK (026) -> 111 101 001 -> 751

666			777	
022			026
-> 644			-> 751


---------chmod command

 `chmod` Command:
The `chmod` (change mode) command in Linux is used to change the access permissions of files and directories. Permissions can be set using either a symbolic or numeric (octal) representation.

# Key Points:
1. Basic Usage: `chmod [options] mode file_name`
   - `mode` specifies the permission settings.
   - `file_name` is the name of the file or directory whose permissions are being changed.

2. Permission Categories:
   - User (`u`): The owner of the file.
   - Group (`g`): The group to which the file belongs.
   - Others (`o`): All other users.
   - All (`a`): All categories (user, group, others).

3. Permission Types:
   - Read (`r`): `4` - Permission to read the file or list a directory's contents.
   - Write (`w`): `2` - Permission to modify the file or create/delete files in a directory.
   - Execute (`x`): `1` - Permission to execute the file (if it's a script or program) or access a directory.

# Examples:

1. Change Permissions Using Symbolic Method:

- Add Execute Permission for the User:
  
  chmod u+x myfile.txt
  
  - Adds execute (`x`) permission for the user (`u`) who owns `myfile.txt`.

- Remove Write Permission for Group:
  
  chmod g-w myfile.txt
  
  - Removes write (`w`) permission for the group (`g`).

- Set Permissions for All to Read Only:
  
  chmod a=r myfile.txt
  
  - Sets permissions for all (`a`) to read-only (`r`).

- Give Read and Execute Permissions to Group and Others:
  
  chmod go+rx myfile.txt
  
  - Adds read (`r`) and execute (`x`) permissions to the group (`g`) and others (`o`).

2. Change Permissions Using Numeric (Octal) Method:

- Set Permissions to `755`:
  
  chmod 755 myfile.txt
  
  - Sets permissions to:
    - User: Read, write, execute (`7` = `rwx`).
    - Group: Read, execute (`5` = `r-x`).
    - Others: Read, execute (`5` = `r-x`).

- Set Permissions to `644`:
  
  chmod 644 myfile.txt
  
  - Sets permissions to:
    - User: Read, write (`6` = `rw-`).
    - Group: Read (`4` = `r--`).
    - Others: Read (`4` = `r--`).

- Set Permissions to `600`:
  
  chmod 600 myfile.txt
  
  - Sets permissions to:
    - User: Read, write (`6` = `rw-`).
    - Group: No permissions (`0` = `---`).
    - Others: No permissions (`0` = `---`).

3. Recursive Permission Changes:

- Change Permissions for All Files in a Directory:
  
  chmod -R 755 /mydirectory
  
  - Recursively sets permissions to `755` for all files and subdirectories within `/mydirectory`.

4. Special Permissions:

- Set the Setuid Bit:
  
  chmod u+s /path/to/program
  
  - Sets the Setuid bit, allowing a program to run with the permissions of the file's owner.

- Set the Setgid Bit:
  
  chmod g+s /path/to/directory
  
  - Sets the Setgid bit on a directory so that files created within inherit the directory's group.

- Set the Sticky Bit:
  
  chmod +t /path/to/directory
  
  - Sets the Sticky Bit on a directory, ensuring only the owner can delete or modify files within it.

5. Combining Multiple Changes:

- Add Execute for User and Remove Write for Others:
  
  chmod u+x,o-w myfile.txt
  
  - Adds execute (`x`) permission for the user (`u`) and removes write (`w`) permission for others (`o`).





-----------fundamentals of processs

 Fundamentals of Processes in Linux

A process in Linux is an instance of a running program. Understanding and managing processes is fundamental for system administration and development. Linux provides several tools and commands to manage processes effectively.

# Key Points:

1. What is a Process?
   - A process is an executing instance of a program, including its code, data, and a unique Process ID (PID).
   - Processes are created using `fork()` or `exec()` system calls and managed by the Linux kernel.

2. Process States:
   - Running (`R`): The process is currently executing or ready to run.
   - Sleeping (`S`): The process is waiting for an event (like I/O) to complete.
   - Stopped (`T`): The process has been stopped, usually by a signal or user.
   - Zombie (`Z`): The process has finished execution but still has an entry in the process table (waiting for the parent process to read its exit status).

3. Process Hierarchy:
   - Every process has a parent, and processes can create child processes. The root of all processes is `init` (PID 1).

# Common Commands for Managing Processes:

1. `ps` - Process Status:
   - Displays information about running processes.
   - Usage: `ps [options]`
   
   Examples:
   - Show All Processes:
     
     ps -aux
     
     - Lists all running processes with detailed information (`-a` for all, `-u` for user-oriented format, `-x` for processes not attached to a terminal).

   - Show User's Processes:
     
     ps -u username
     
     - Displays all processes owned by the specified user.

   - Tree View of Processes:
     
     ps -ejH
     
     - Shows processes in a hierarchical tree format.

2. `top` - Real-time Process Monitoring:
   - Displays real-time information about running processes, including CPU and memory usage.
   - Usage: `top [options]`
   
   Examples:
   - Start `top`:
     
     top
     
     - Launches `top` with default settings, displaying a dynamic list of processes.

   - Sort by Memory Usage:
     Press `M` while in `top` to sort processes by memory usage.

   - Quit `top`:
     Press `q` to exit `top`.

3. `htop` - Enhanced Process Viewer:
   - Similar to `top` but with an improved interface, allowing easier process management (not installed by default on all distributions).
   - Usage: `htop`

4. `bg` - Background a Job:
   - Resumes a suspended job in the background.
   - Usage: `bg [job_spec]`
   
   Examples:
   - Resume the Last Suspended Job in Background:
     
     bg
     
     - Sends the most recently suspended job to the background.

   - Resume Specific Job:
     
     bg %1
     
     - Resumes job number 1 in the background.

5. `fg` - Foreground a Job:
   - Brings a background job to the foreground.
   - Usage: `fg [job_spec]`
   
   Examples:
   - Bring the Last Job to Foreground:
     
     fg
     
     - Brings the most recently suspended or background job to the foreground.

   - Bring Specific Job to Foreground:
     
     fg %2
     
     - Brings job number 2 to the foreground.

6. `kill` - Terminate a Process:
   - Sends a signal to a process, usually to terminate it.
   - Usage: `kill [signal] PID`
   
   Examples:
   - Terminate a Process:
     
     kill 1234
     
     - Sends the default `SIGTERM` signal to terminate the process with PID `1234`.

   - Forcefully Kill a Process:
     
     kill -9 1234
     
     - Sends the `SIGKILL` signal to forcefully terminate the process with PID `1234`.

7. `jobs` - List Active Jobs:
   - Displays a list of current jobs running in the background or stopped.
   - Usage: `jobs [options]`
   
   Examples:
   - List All Jobs:
     
     jobs
     
     - Shows all background jobs and their statuses.

8. `nice` and `renice` - Set Process Priority:
   - `nice` sets the priority for a new process, and `renice` changes the priority of an existing process.
   - Usage: `nice [-n adjustment] command` and `renice [priority] -p PID`
   
   Examples:
   - Start a Process with Lower Priority:
     
     nice -n 10 command
     
     - Starts `command` with a priority adjustment of `10`.

   - Change Priority of Running Process:
     
     renice 15 -p 5678
     
     - Changes the priority of process with PID `5678` to `15`.

9. `pkill` - Kill Processes by Name:
   - Terminates processes based on their name.
   - Usage: `pkill [options] pattern`
   
   Examples:
   - Kill All `python` Processes:
     
     pkill python
     
     - Sends the default termination signal to all processes named `python`.

10. `pgrep` - Find Processes by Name:
    - Lists the PIDs of processes that match a given name.
    - Usage: `pgrep [options] pattern`
    
    Examples:
    - Find All `bash` Processes:
      
      pgrep bash
      
      - Displays the PIDs of all processes named `bash`.





------------process signals

1  => HUP  ->  Hang Up
2  => INT  ->  Interrupt (Same as CTRL-C)
3  => QUIT ->  Just simple quit
9  => KILL ->  Kill without notifying the program, Contacts directly with kernel
11 => SEGV ->  Segmentation Violation 
15 => TERM ->  Default signal sent by kill command.
18 => CONT ->  Continue | Restore process after a STOP or TSTP signal (sent by BG and FG)
19 => STOP ->  Pause without terminating. (program cannot ignore this)
20 => TSTP ->  Terminal Stop. CTRL-Z is pressed. (can be ignorable)
28 => WINCH->  Window change 




----------packet management systems in Linux
 Package Management Systems in Linux

Package management is a critical part of Linux system administration. It involves installing, updating, configuring, and removing software packages from a system in an efficient and secure way. Linux distributions rely on package management systems (PMS) to handle software packages.

# 1. Introduction to Package Management Systems

- Definition: A Package Management System (PMS) is a collection of tools to automate the process of installing, upgrading, configuring, and removing software.
- Components:
  - Package: A compressed archive that contains all files required to install a specific application or software.
  - Repository: A centralized storage location from which packages can be downloaded and installed.
  - Package Manager: A tool that allows users to manage packages, including their installation, upgrades, dependencies, and removal.

# 2. Why We Need Package Management Tools

- Dependency Management: Many software applications depend on other libraries or tools to function correctly. Package managers automatically handle these dependencies.
- Simplifies Software Installation: Instead of manually downloading and compiling software, package managers allow for easy installation with a single command.
- Centralized Updates: Provides a unified way to update all software packages to the latest versions, ensuring system security and stability.
- Consistency: Ensures all packages are correctly installed and configured, reducing the likelihood of broken or mismatched libraries.
- Security: Verifies the authenticity and integrity of packages to protect against tampered or malicious software.
- Convenience: Provides tools for bulk operations, such as updating or removing multiple packages simultaneously.

# 3. Package Management in Linux

Linux distributions use different package management systems based on their design philosophy and package format. The two major types are Debian-based (APT) and Red Hat-based (RPM) package management systems.

## 3.1. Debian-based Package Management (`APT`)

- APT (Advanced Package Tool): APT is the package management system used by Debian-based distributions, like Ubuntu.
- Key Commands:
  - Update Package Index:
    
    sudo apt update
    
    - Refreshes the list of available packages and their versions from repositories.

  - Install a Package:
    
    sudo apt install package_name
    
    - Installs the specified package, resolving and installing dependencies.

  - Remove a Package:
    
    sudo apt remove package_name
    
    - Uninstalls the package but retains configuration files.

  - Purge a Package:
    
    sudo apt purge package_name
    
    - Uninstalls the package and removes all its configuration files.

  - Upgrade All Packages:
    
    sudo apt upgrade
    
    - Upgrades all installed packages to their latest versions.

  - Search for a Package:
    
    apt search keyword
    
    - Searches for packages matching a given keyword.

## 3.2. Red Hat-based Package Management (`RPM` and `DNF/YUM`)

- RPM (Red Hat Package Manager): The base package management system used in Red Hat-based distributions, like RHEL, CentOS, and Fedora.
- DNF/YUM: `DNF` (Dandified YUM) is the next-generation version of `YUM` (Yellowdog Updater, Modified), providing additional features and better performance.

- Key Commands:

  - Install a Package Using `DNF`:
    
    sudo dnf install package_name
    
    - Installs the specified package, resolving dependencies.

  - Remove a Package:
    
    sudo dnf remove package_name
    
    - Uninstalls the package.

  - Update All Packages:
    
    sudo dnf update
    
    - Upgrades all installed packages to their latest versions.

  - Search for a Package:
    
    dnf search keyword
    
    - Searches for packages matching a keyword.

  - Install a Package Using `RPM`:
    
    sudo rpm -ivh package_name.rpm
    
    - Installs a `.rpm` package from a local file.

  - Query Installed Packages:
    
    rpm -qa | grep package_name
    
    - Lists installed packages and their details.

## 3.3. Universal Package Management Systems

- `snap`: Developed by Canonical, used for distributing self-contained packages called "snaps" that run on various Linux distributions.
  - Install a Snap:
    
    sudo snap install package_name
    

- `flatpak`: A universal package management system for Linux that allows running sandboxed applications across different distributions.
  - Install a Flatpak Package:
    
    flatpak install repo_name package_name
    

- `AppImage`: A format for packaging applications that can run on any Linux distribution without installation. Requires downloading and making the file executable.




----------TCP/IP

 TCP/IP and Networking Fundamentals

The TCP/IP model (Transmission Control Protocol/Internet Protocol) is the foundation of networking and the internet. It defines how data is transmitted across networks and provides the rules for communication between devices. Understanding the TCP/IP model and networking fundamentals is essential for anyone working with networks or the internet.

# 1. What is a Network Protocol and What Does It Do?

- Definition: A network protocol is a set of rules and conventions that devices follow to communicate over a network.
- Function: Network protocols define how data is formatted, transmitted, and received, ensuring that devices on a network can communicate effectively. Examples include TCP, IP, HTTP, FTP, and SMTP.
- Purpose: Protocols ensure reliable and efficient data transfer between devices, manage network traffic, and handle error detection and correction.

# 2. Layers of the TCP/IP Model

The TCP/IP model is a simplified, four-layer framework that outlines how data is transmitted over networks:

1. Application Layer: 
   - Interfaces with software applications to implement a communication component.
   - Protocols: HTTP, FTP, SMTP, DNS, etc.

2. Transport Layer:
   - Ensures reliable communication and data integrity between hosts.
   - Protocols: TCP (reliable, connection-oriented), UDP (unreliable, connectionless).

3. Internet Layer:
   - Responsible for addressing, packaging, and routing data across the network.
   - Protocols: IP (IPv4, IPv6), ICMP, ARP.

4. Network Interface Layer (also known as Link Layer):
   - Manages the physical transmission of data over network hardware.
   - Protocols: Ethernet, Wi-Fi, PPP.

# 3. How Emails Are Sent and Received Over the Internet

- Email Transmission Protocols:
  - SMTP (Simple Mail Transfer Protocol): Used to send emails from the sender's email client to the server and between servers.
  - IMAP (Internet Message Access Protocol) and POP3 (Post Office Protocol version 3): Used to retrieve emails from the server to the recipient's email client.
  
Email Process:

1. Sending an Email:
   - A user composes an email in their client (e.g., Gmail).
   - The client sends the email to the sender's SMTP server.
   - The SMTP server relays the email to the recipient's SMTP server over the internet using TCP/IP.

2. Receiving an Email:
   - The recipient's email server receives the email and stores it.
   - The recipient's client retrieves the email using IMAP or POP3.

# 4. PDU (Protocol Data Unit) Explained

- Definition: A Protocol Data Unit (PDU) is a unit of data specified in a protocol of a particular layer of the TCP/IP model.
- Examples:
  - Application Layer: Data (message or file)
  - Transport Layer: Segment (TCP) or Datagram (UDP)
  - Internet Layer: Packet
  - Network Interface Layer: Frame

Each layer encapsulates its PDU in the header and passes it to the next layer until it reaches the physical medium for transmission.

# 5. Basic Use of Switch and Data Transmission

- What is a Switch?:
  - A network switch is a device that connects multiple devices on a Local Area Network (LAN) and forwards data based on MAC addresses.
  - Switches operate at the Data Link Layer (Layer 2) of the TCP/IP model.

- Data Transmission:
  - When a device sends data, the switch receives the frame and looks at the destination MAC address.
  - The switch forwards the frame only to the port connected to the destination device, ensuring efficient data transmission.

# 6. Two Networks Talking with a Router in the Middle

- What is a Router?:
  - A router is a device that connects two or more networks and forwards data packets between them based on IP addresses.
  - Routers operate at the Internet Layer (Layer 3) of the TCP/IP model.

- Data Transmission Between Networks:
  - When a device on Network A wants to communicate with a device on Network B, the data packet is sent to the router.
  - The router examines the destination IP address and determines the best path to forward the packet to reach Network B.
  - The router uses routing tables and protocols (like OSPF, BGP) to make forwarding decisions, ensuring data reaches its destination efficiently.




--------networking in Linux

 Networking with Linux

Linux provides a variety of networking tools and commands that allow users and administrators to diagnose, configure, and manage network connections effectively. Understanding these tools is essential for troubleshooting and maintaining a healthy network environment.

# 1. `traceroute` Command (`trcrt` in Windows)

- Definition: `traceroute` is a network diagnostic tool that traces the path data takes to reach a destination (such as a website or an IP address). It helps in identifying network delays or bottlenecks.
- Usage: 
  - The `traceroute` command sends packets with incremental Time-To-Live (TTL) values to the destination. Each time the packet's TTL reaches zero, the router sends back an error message (ICMP Time Exceeded). This process reveals each hop along the route.
  
- Syntax:
  
  traceroute [destination]
  

- Example:
  
  traceroute google.com
  
  - This command displays the route taken by packets from your machine to `google.com`, along with the time taken at each hop.

# 2. Networking with Linux

Linux provides a range of tools and commands to manage, configure, and troubleshoot network connections.

## 2.1. Checking Network Configuration

- `ifconfig` (deprecated) / `ip` command:
  - Used to display or configure network interfaces.
  - Syntax:
    
    ip addr show
    
  - Example:
    
    ip addr show eth0
    
    - Displays detailed information about the `eth0` interface, such as its IP address, subnet mask, and broadcast address.

## 2.2. Checking Connectivity

- `ping` command:
  - Tests the connectivity between two devices by sending ICMP echo requests.
  - Syntax:
    
    ping [destination]
    
  - Example:
    
    ping google.com
    
    - Sends continuous pings to `google.com` to check if it is reachable and displays the round-trip time for each packet.

## 2.3. Managing Network Routes

- `route` command (deprecated) / `ip route`:
  - Used to display or manipulate the IP routing table.
  - Syntax:
    
    ip route show
    
  - Example:
    
    ip route add default via 192.168.1.1
    
    - Sets the default gateway to `192.168.1.1`.

## 2.4. Monitoring Network Traffic

- `netstat` (deprecated) / `ss` command:
  - Used to display network connections, routing tables, interface statistics, and more.
  - Syntax:
    
    ss -tuln
    
  - Example:
    
    ss -tuln
    
    - Lists all listening ports (TCP and UDP) and their respective states.

## 2.5. Network Troubleshooting Tools

- `tcpdump`:
  - A powerful packet analyzer that captures and displays network packets.
  - Syntax:
    
    tcpdump -i [interface]
    
  - Example:
    
    tcpdump -i eth0
    
    - Captures all packets on the `eth0` interface for analysis.

- `nmap`:
  - A network scanning tool used for network discovery and security auditing.
  - Syntax:
    
    nmap [options] [target]
    
  - Example:
    
    nmap -sP 192.168.1.0/24
    
    - Scans the entire `192.168.1.0/24` subnet to discover active hosts.
